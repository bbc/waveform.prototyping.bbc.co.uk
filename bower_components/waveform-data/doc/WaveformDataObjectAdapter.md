# WaveformDataObjectAdapter

<table>
  <tbody>
    <tr>
      <th><code>response_data</code></th>
      <td><code>String</code> | <code>Object</code></td>
      <td>JSON or stringified JSON</td>
    </tr>
  </body>
</table>

* See: `WaveformDataObjectAdapter.fromResponseData`
* `@constructor`


> Object adapter consumes stringified JSON or JSON waveform data (data format version 1).
It is used as a data abstraction layer by `WaveformData`.

This is supposed to be a fallback for browsers not supporting ArrayBuffer:
* **Pros**: easy to debug response_data and quite self describing.
* **Cons**: slower than ArrayBuffer, more memory consumption.

Also, it is recommended to use the `fromResponseData` factory.

# WaveformDataObjectAdapter.isCompatible()

<table>
  <tbody>
    <tr>
      <th><code>data</code></th>
      <td><code>Mixed</code></td>
      <td></td>
    </tr>
  </body>
</table>

* `@static`
* `@returns`


> Detects if a set of data is suitable for the Object adapter.
It is used internally by `WaveformData.create` so you should not bother using it.

# WaveformDataObjectAdapter.fromResponseData()

<table>
  <tbody>
    <tr>
      <th><code>response_data</code></th>
      <td><code>String</code> | <code>Object</code></td>
      <td>JSON or stringified JSON</td>
    </tr>
  </body>
</table>

* `@static`
* `@return` `WaveformDataObjectAdapter`


> Setup factory to create an adapter based on heterogeneous input formats.

It is the preferred way to build an adapter instance.

```javascript
var objectAdapter = WaveformData.adapters.object;
var xhr = new XMLHttpRequest();

// .dat file generated by audiowaveform program (JSON representation of https://github.com/bbcrd/audiowaveform/blob/master/doc/DataFormat.md)
xhr.open("GET", "http://example.com/waveforms/track.json");
xhr.responseType = "json";
xhr.addEventListener("load", function onResponse(progressEvent){
 var responseData = progressEvent.target.response;

 // doing stuff with the raw data ...
 // you only have access to WaveformDataObjectAdapter API
 var adapter = objectAdapter.fromResponseData(responseData);

 // or making things easy by using WaveformData ...
 // you have access WaveformData API
 var waveform = new WaveformData(responseData, objectAdapter);
});

xhr.send();
```

# WaveformDataObjectAdapter.prototype.version


* `@return` `Integer` Version number of the consumed data format.


> Returns the data format version number.

# WaveformDataObjectAdapter.prototype.is_8_bit


* `@return` `boolean` True if data are declared to be 8bits encoded.


> Indicates if the response body is encoded in 8bits.

**Notice**: currently the adapter only deals with 8bits encoded data.
You should favor that too because of the smaller data network fingerprint.

# WaveformDataObjectAdapter.prototype.is_16_bit


* `@return` `boolean` True if data are declared to be 16bits encoded.


> Indicates if the response body is encoded in 16bits.

# WaveformDataObjectAdapter.prototype.sample_rate


* `@return` `Integer` Number of samples per second.


> Returns the number of samples per second.

# WaveformDataObjectAdapter.prototype.scale


* `@return` `Integer` Number of samples per pixel.


> Returns the scale (number of samples per pixel).

# WaveformDataObjectAdapter.prototype.length


* `@return` `Integer` Length of the waveform data.


> Returns the length of the waveform data (number of data points).

# WaveformDataObjectAdapter.prototype.at()

<table>
  <tbody>
    <tr>
      <th><code>index</code></th>
      <td><code>Integer</code></td>
      <td></td>
    </tr>
  </body>
</table>

* `@return` `number` waveform value


> Returns a value at a specific offset.
